// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package collection

type SetString struct {
	values map[string]struct{}
}

func NewSetString(elements ...string) *SetString {
	set := &SetString{
		values: make(map[string]struct{}),
	}
	for _, element := range elements {
		set.add(element)
	}

	return set
}

func (set *SetString) has(elem string) bool {
	_, exist := set.values[elem]
	return exist
}

func (set *SetString) add(elem string) {
	if set.values == nil {
		set.values = make(map[string]struct{})
	}
	set.values[elem] = struct{}{}
}

func (set *SetString) Add(elem string) bool {
	if set.has(elem) {
		return true
	}
	set.add(elem)
	return false
}

func (set *SetString) Update(elements ...string) {
	for _, element := range elements {
		set.add(element)
	}
}

func (set *SetString) Remove(elem string) bool {
	if !set.has(elem) {
		return false
	}
	delete(set.values, elem)
	return true
}

func (set *SetString) Has(elem string) bool {
	return set.has(elem)
}

// 遍历集合
func (set *SetString) Range(f func(element string)) {
	for value := range set.values {
		f(value)
	}
}

// copy一个新的集合
func (set *SetString) Copy() *SetString {
	copyed := NewSetString()
	set.Range(func(element string) {
		copyed.Add(element)
	})
	return copyed
}

// 求并集
func (set *SetString) Union(another *SetString) *SetString {
	union := set.Copy()
	another.Range(func(element string) {
		union.Add(element)
	})
	return union
}

// 求交集
func (set *SetString) Intersect(another *SetString) *SetString {
	intersect := NewSetString()
	set.Range(func(element string) {
		if another.Has(element) {
			intersect.Add(element)
		}
	})
	return intersect
}

// 求差集
func (set *SetString) Except(another *SetString) *SetString {
	except := NewSetString()
	set.Range(func(element string) {
		if !another.Has(element) {
			except.Add(element)
		}
	})
	return except
}

// 集合长度
func (set *SetString) Length() int {
	return len(set.values)
}

// 集合转化为slice结构
func (set *SetString) StringList() []string {
	lst := make([]string, 0, set.Length())
	set.Range(func(element string) {
		lst = append(lst, element)
	})

	return lst
}

type SetInt struct {
	values map[int]struct{}
}

func NewSetInt(elements ...int) *SetInt {
	set := &SetInt{
		values: make(map[int]struct{}),
	}
	for _, element := range elements {
		set.add(element)
	}

	return set
}

func (set *SetInt) has(elem int) bool {
	_, exist := set.values[elem]
	return exist
}

func (set *SetInt) add(elem int) {
	if set.values == nil {
		set.values = make(map[int]struct{})
	}
	set.values[elem] = struct{}{}
}

func (set *SetInt) Add(elem int) bool {
	if set.has(elem) {
		return true
	}
	set.add(elem)
	return false
}

func (set *SetInt) Update(elements ...int) {
	for _, element := range elements {
		set.add(element)
	}
}

func (set *SetInt) Remove(elem int) bool {
	if !set.has(elem) {
		return false
	}
	delete(set.values, elem)
	return true
}

func (set *SetInt) Has(elem int) bool {
	return set.has(elem)
}

// 遍历集合
func (set *SetInt) Range(f func(element int)) {
	for value := range set.values {
		f(value)
	}
}

// copy一个新的集合
func (set *SetInt) Copy() *SetInt {
	copyed := NewSetInt()
	set.Range(func(element int) {
		copyed.Add(element)
	})
	return copyed
}

// 求并集
func (set *SetInt) Union(another *SetInt) *SetInt {
	union := set.Copy()
	another.Range(func(element int) {
		union.Add(element)
	})
	return union
}

// 求交集
func (set *SetInt) Intersect(another *SetInt) *SetInt {
	intersect := NewSetInt()
	set.Range(func(element int) {
		if another.Has(element) {
			intersect.Add(element)
		}
	})
	return intersect
}

// 求差集
func (set *SetInt) Except(another *SetInt) *SetInt {
	except := NewSetInt()
	set.Range(func(element int) {
		if !another.Has(element) {
			except.Add(element)
		}
	})
	return except
}

// 集合长度
func (set *SetInt) Length() int {
	return len(set.values)
}

// 集合转化为slice结构
func (set *SetInt) IntList() []int {
	lst := make([]int, 0, set.Length())
	set.Range(func(element int) {
		lst = append(lst, element)
	})

	return lst
}

type SetInt64 struct {
	values map[int64]struct{}
}

func NewSetInt64(elements ...int64) *SetInt64 {
	set := &SetInt64{
		values: make(map[int64]struct{}),
	}
	for _, element := range elements {
		set.add(element)
	}

	return set
}

func (set *SetInt64) has(elem int64) bool {
	_, exist := set.values[elem]
	return exist
}

func (set *SetInt64) add(elem int64) {
	if set.values == nil {
		set.values = make(map[int64]struct{})
	}
	set.values[elem] = struct{}{}
}

func (set *SetInt64) Add(elem int64) bool {
	if set.has(elem) {
		return true
	}
	set.add(elem)
	return false
}

func (set *SetInt64) Update(elements ...int64) {
	for _, element := range elements {
		set.add(element)
	}
}

func (set *SetInt64) Remove(elem int64) bool {
	if !set.has(elem) {
		return false
	}
	delete(set.values, elem)
	return true
}

func (set *SetInt64) Has(elem int64) bool {
	return set.has(elem)
}

// 遍历集合
func (set *SetInt64) Range(f func(element int64)) {
	for value := range set.values {
		f(value)
	}
}

// copy一个新的集合
func (set *SetInt64) Copy() *SetInt64 {
	copyed := NewSetInt64()
	set.Range(func(element int64) {
		copyed.Add(element)
	})
	return copyed
}

// 求并集
func (set *SetInt64) Union(another *SetInt64) *SetInt64 {
	union := set.Copy()
	another.Range(func(element int64) {
		union.Add(element)
	})
	return union
}

// 求交集
func (set *SetInt64) Intersect(another *SetInt64) *SetInt64 {
	intersect := NewSetInt64()
	set.Range(func(element int64) {
		if another.Has(element) {
			intersect.Add(element)
		}
	})
	return intersect
}

// 求差集
func (set *SetInt64) Except(another *SetInt64) *SetInt64 {
	except := NewSetInt64()
	set.Range(func(element int64) {
		if !another.Has(element) {
			except.Add(element)
		}
	})
	return except
}

// 集合长度
func (set *SetInt64) Length() int {
	return len(set.values)
}

// 集合转化为slice结构
func (set *SetInt64) Int64List() []int64 {
	lst := make([]int64, 0, set.Length())
	set.Range(func(element int64) {
		lst = append(lst, element)
	})

	return lst
}

type SetInt32 struct {
	values map[int32]struct{}
}

func NewSetInt32(elements ...int32) *SetInt32 {
	set := &SetInt32{
		values: make(map[int32]struct{}),
	}
	for _, element := range elements {
		set.add(element)
	}

	return set
}

func (set *SetInt32) has(elem int32) bool {
	_, exist := set.values[elem]
	return exist
}

func (set *SetInt32) add(elem int32) {
	if set.values == nil {
		set.values = make(map[int32]struct{})
	}
	set.values[elem] = struct{}{}
}

func (set *SetInt32) Add(elem int32) bool {
	if set.has(elem) {
		return true
	}
	set.add(elem)
	return false
}

func (set *SetInt32) Update(elements ...int32) {
	for _, element := range elements {
		set.add(element)
	}
}

func (set *SetInt32) Remove(elem int32) bool {
	if !set.has(elem) {
		return false
	}
	delete(set.values, elem)
	return true
}

func (set *SetInt32) Has(elem int32) bool {
	return set.has(elem)
}

// 遍历集合
func (set *SetInt32) Range(f func(element int32)) {
	for value := range set.values {
		f(value)
	}
}

// copy一个新的集合
func (set *SetInt32) Copy() *SetInt32 {
	copyed := NewSetInt32()
	set.Range(func(element int32) {
		copyed.Add(element)
	})
	return copyed
}

// 求并集
func (set *SetInt32) Union(another *SetInt32) *SetInt32 {
	union := set.Copy()
	another.Range(func(element int32) {
		union.Add(element)
	})
	return union
}

// 求交集
func (set *SetInt32) Intersect(another *SetInt32) *SetInt32 {
	intersect := NewSetInt32()
	set.Range(func(element int32) {
		if another.Has(element) {
			intersect.Add(element)
		}
	})
	return intersect
}

// 求差集
func (set *SetInt32) Except(another *SetInt32) *SetInt32 {
	except := NewSetInt32()
	set.Range(func(element int32) {
		if !another.Has(element) {
			except.Add(element)
		}
	})
	return except
}

// 集合长度
func (set *SetInt32) Length() int {
	return len(set.values)
}

// 集合转化为slice结构
func (set *SetInt32) Int32List() []int32 {
	lst := make([]int32, 0, set.Length())
	set.Range(func(element int32) {
		lst = append(lst, element)
	})

	return lst
}
