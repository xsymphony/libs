// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package slices

func MapBool(f func(bool) bool, s []bool) []bool {
	n := make([]bool, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterBool(f func(bool) bool, s []bool) []bool {
	n := make([]bool, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceBool(f func(bool, bool) bool, s []bool) bool {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapByte(f func(byte) byte, s []byte) []byte {
	n := make([]byte, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterByte(f func(byte) bool, s []byte) []byte {
	n := make([]byte, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceByte(f func(byte, byte) byte, s []byte) byte {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapComplex128(f func(complex128) complex128, s []complex128) []complex128 {
	n := make([]complex128, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterComplex128(f func(complex128) bool, s []complex128) []complex128 {
	n := make([]complex128, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceComplex128(f func(complex128, complex128) complex128, s []complex128) complex128 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapComplex64(f func(complex64) complex64, s []complex64) []complex64 {
	n := make([]complex64, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterComplex64(f func(complex64) bool, s []complex64) []complex64 {
	n := make([]complex64, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceComplex64(f func(complex64, complex64) complex64, s []complex64) complex64 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapError(f func(error) error, s []error) []error {
	n := make([]error, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterError(f func(error) bool, s []error) []error {
	n := make([]error, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceError(f func(error, error) error, s []error) error {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapFloat32(f func(float32) float32, s []float32) []float32 {
	n := make([]float32, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterFloat32(f func(float32) bool, s []float32) []float32 {
	n := make([]float32, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceFloat32(f func(float32, float32) float32, s []float32) float32 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapFloat64(f func(float64) float64, s []float64) []float64 {
	n := make([]float64, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterFloat64(f func(float64) bool, s []float64) []float64 {
	n := make([]float64, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceFloat64(f func(float64, float64) float64, s []float64) float64 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapInt(f func(int) int, s []int) []int {
	n := make([]int, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterInt(f func(int) bool, s []int) []int {
	n := make([]int, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceInt(f func(int, int) int, s []int) int {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapInt16(f func(int16) int16, s []int16) []int16 {
	n := make([]int16, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterInt16(f func(int16) bool, s []int16) []int16 {
	n := make([]int16, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceInt16(f func(int16, int16) int16, s []int16) int16 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapInt32(f func(int32) int32, s []int32) []int32 {
	n := make([]int32, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterInt32(f func(int32) bool, s []int32) []int32 {
	n := make([]int32, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceInt32(f func(int32, int32) int32, s []int32) int32 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapInt64(f func(int64) int64, s []int64) []int64 {
	n := make([]int64, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterInt64(f func(int64) bool, s []int64) []int64 {
	n := make([]int64, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceInt64(f func(int64, int64) int64, s []int64) int64 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapInt8(f func(int8) int8, s []int8) []int8 {
	n := make([]int8, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterInt8(f func(int8) bool, s []int8) []int8 {
	n := make([]int8, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceInt8(f func(int8, int8) int8, s []int8) int8 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapRune(f func(rune) rune, s []rune) []rune {
	n := make([]rune, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterRune(f func(rune) bool, s []rune) []rune {
	n := make([]rune, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceRune(f func(rune, rune) rune, s []rune) rune {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapString(f func(string) string, s []string) []string {
	n := make([]string, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterString(f func(string) bool, s []string) []string {
	n := make([]string, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceString(f func(string, string) string, s []string) string {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapUint(f func(uint) uint, s []uint) []uint {
	n := make([]uint, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterUint(f func(uint) bool, s []uint) []uint {
	n := make([]uint, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceUint(f func(uint, uint) uint, s []uint) uint {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapUint16(f func(uint16) uint16, s []uint16) []uint16 {
	n := make([]uint16, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterUint16(f func(uint16) bool, s []uint16) []uint16 {
	n := make([]uint16, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceUint16(f func(uint16, uint16) uint16, s []uint16) uint16 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapUint32(f func(uint32) uint32, s []uint32) []uint32 {
	n := make([]uint32, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterUint32(f func(uint32) bool, s []uint32) []uint32 {
	n := make([]uint32, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceUint32(f func(uint32, uint32) uint32, s []uint32) uint32 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapUint64(f func(uint64) uint64, s []uint64) []uint64 {
	n := make([]uint64, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterUint64(f func(uint64) bool, s []uint64) []uint64 {
	n := make([]uint64, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceUint64(f func(uint64, uint64) uint64, s []uint64) uint64 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapUint8(f func(uint8) uint8, s []uint8) []uint8 {
	n := make([]uint8, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterUint8(f func(uint8) bool, s []uint8) []uint8 {
	n := make([]uint8, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceUint8(f func(uint8, uint8) uint8, s []uint8) uint8 {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}

func MapUintptr(f func(uintptr) uintptr, s []uintptr) []uintptr {
	n := make([]uintptr, 0, len(s))
	for i := 0; i < len(s); i++ {
		n = append(n, f(s[i]))
	}
	return n
}

func FilterUintptr(f func(uintptr) bool, s []uintptr) []uintptr {
	n := make([]uintptr, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			n = append(n, s[i])
		}
	}
	return n
}

func ReduceUintptr(f func(uintptr, uintptr) uintptr, s []uintptr) uintptr {
	t := s[0]
	for i := 1; i < len(s); i++ {
		t = f(t, s[i])
	}
	return t
}
